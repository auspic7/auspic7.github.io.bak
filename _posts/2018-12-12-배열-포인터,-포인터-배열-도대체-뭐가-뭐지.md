---
title:  "배열 포인터, 포인터 배열 도대체 뭐가 뭐지?"
permalink: "/:categories/array-and-pointer"
date: 2018-12-12 01:00:00 +0900
categories: [C++]
tags: [C++, array, pointer, programming, data structure]
typora-root-url: /Users/myeongwon/blog/

---

C 프로그래밍을 하다 보면 사람을 무지하게 골때리게 하는 것이 바로 포인터입니다. 이게 배울 때만 어렵고 배우고 나면 좀 짜기 수월할 거 같았는데 그게 아니라 짜다보면 더 햇갈리는게 포인터더라구요. 그래서 여기서 정리를 한번 잘 해서 햇갈리는 일이 없도록 합시다.

# 본문

먼저 배열 포인터와 포인터 배열에 관해 다루기 전에 기본적인 개념에 대해서 확실히 하고 넘어갑니다.

## 개념 정리하고 넘어가기

### 배열의 정의

> An array is a contiguous collection of homogeneous elements that can be accessed using
> an index. By contiguous, we mean the elements of the array are adjacent to one another
> in memory with no gaps between them. By homogeneous, we mean they are all of the
> same type. Array declarations use a set of brackets and can possess multiple dimensions.

<cite>Richard M Reese</cite> --- Understanding and Using C Pointers
{: .small}

배열은 동형의 연속된 원소의 모음이랍니다. 여기서 동형이란 단어에서 각 원소의 타입이 같다는 사실을 알 수 있고, 연속이라는 단어에서 중간에 빈 공간이 없이 채워져 있다는 사실을 알 수 있네요.

### **배열 이름**은 포인터 상수인가?

> A common misconception is that an array and a pointer are completely interchangeable.
> An array name is not a pointer. Although an array name can be treated as a pointer at
> times, and array notation can be used with pointers, they are distinct and cannot always
> be used in place of each other. Understanding this difference will help you avoid incor‐
> rect use of these notations. For example, although the name of an array used by itself
> will return the array’s address, we cannot use the name by itself as the target of an
> assignment.

<cite>Richard M Reese</cite> --- Understanding and Using C Pointers
{: .small}

배열 이름은 포인터와 혼용될 수 있지만 일단은 다르답니다. 근데 여기서 사실 포인터 상수라는 개념이 언급되진 않았기 때문에 완전히 아닌가에 대해서는 아직 의문이 남습니다.

> When an array name is used by itself, the array’s address is returned. We can assign this
> address to a pointer as illustrated below:
>
> ```c++
> int vector[5] = {1, 2, 3, 4, 5};
> int *pv = vector;
> ```
>
> The variable pv is a pointer to the first element of the array and not the array itself. When
> we first assigned a value to pv, we assigned the address of the array’s first element.

배열 이름이 그 자체로 사용되었을 때에는 배열의 주소가 반환된다고 합니다. 그러나 위 코드에서 변수 pv는 배열의 첫 번째 원소로의 포인터일 뿐 배열 그 차체는 아니라고 합니다.

>The code generated by `vector[i]` is different from the code generated by `vector+i`.
>The notation `vector[i]` generates machine code that starts at location `vector`, moves
>`i` positions from this location, and uses its content. The notation `vector+i` generates
>machine code that starts at location `vector`, adds `i` to the address, and then uses the
>contents at that address. While the result is the same, the generated machine code is
>different. This difference is rarely of significance to most programmers.

여기서는 꽤나 흥미로운 내용이 나옵니다. `vector[i]`로 인해 생성된 기계어와 `vector+i`는 서로 다른 모습을 띄는데, `vector[i]`로 인해 생성된 기계어는 `vector`의 지점에서 시작하여, `i`개 만큼 이동하고, 그 지점의 내용을 사용하는 데에 반해,  `vector+i`의 노테이션은 `vector`의 지점에서 시작해, 주소에 `i`를 *더하고*, 그 지점의 내용을 사용한다고 하네요. 결과가 같더라도, 생성된 기계어는 다르답니다. 하지만 대부분 프로그래머에게 그다지 중요한 내용은 아니라고 하네요.

> There is a difference when the `sizeof` operator is applied to an array and to a pointer
> to the same array. Applying the `sizeof` operator to vector will return 20, the number
> of bytes allocated to the array. Applying the `sizeof` operator against `pv` will return 4,
> the pointer’s size.

여기서 배열 이름과 포인터 상수의 차이점이 또 나타나네요. 같은 배열을 가리키는 포인터와 배열 이름에 각각 `sizeof` 연산자를 사용할 경우 배열 이름의 경우 배열 전체의 크기를 리턴하지만 포인터에 `sizeof`  연산자를 사용하면 포인터의 크기인 4를 리턴하게 되겠지요.

### 이차원 배열과 포인터 배열

> Two-dimensional arrays are common, and we typically use the terms rows and columns
> to describe the position of an array’s element. Arrays with three or more dimensions
> are not as common but can be quite useful in some applications. **A two-dimensional
> array is not to be confused with an array of pointers.** They are similar but behave slightly
> differently.

<cite>Richard M Reese</cite> --- Understanding and Using C Pointers
{: .small}

이차원 배열은 포인터 배열과 유사하나 결코 혼동되어서는 안 된다고 합니다.

